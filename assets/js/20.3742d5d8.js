(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{344:function(v,a,t){"use strict";t.r(a);var _=t(3),s=Object(_.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"java面向对象基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java面向对象基础"}},[v._v("#")]),v._v(" Java面向对象基础")]),v._v(" "),a("h2",{attrs:{id:"面向对象三大特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象三大特性"}},[v._v("#")]),v._v(" 面向对象三大特性")]),v._v(" "),a("h3",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[v._v("#")]),v._v(" 继承")]),v._v(" "),a("p",[v._v("⭐ "),a("strong",[v._v("描述")]),v._v("："),a("strong",[v._v("子类继承父类的特征和行为")]),v._v("，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。")]),v._v(" "),a("p",[v._v("⭐ "),a("strong",[v._v("意义")]),v._v("：为了提高代码的复用性和可扩展性，在定义不同类的时候存在一些相同的属性，为了方便使用，可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义。")]),v._v(" "),a("p",[v._v("⭐ "),a("strong",[v._v("特性")]),v._v("：")]),v._v(" "),a("ul",[a("li",[v._v("子类拥有父类非 private 的属性、方法。")]),v._v(" "),a("li",[v._v("子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。")]),v._v(" "),a("li",[v._v("子类可以用自己的方式实现父类的方法。")]),v._v(" "),a("li",[v._v("Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。")]),v._v(" "),a("li",[v._v("提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。")])]),v._v(" "),a("h3",{attrs:{id:"封装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[v._v("#")]),v._v(" 封装")]),v._v(" "),a("p",[v._v("⭐ "),a("strong",[v._v("描述")]),v._v("：把一个对象的属性和方法隐藏在对象内部，不允许外部对象直接访问对象的内部信息。相当于把一个事物的状态信息和功能隐藏在其内部。但是可以提供一些可以被外界访问的方法来操作属性。如果属性不想被外界访问，我们不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，这个类就没有意义了。")]),v._v(" "),a("h3",{attrs:{id:"多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[v._v("#")]),v._v(" "),a("strong",[v._v("多态")])]),v._v(" "),a("p",[v._v("⭐ "),a("strong",[v._v("描述")]),v._v("：多态是"),a("strong",[v._v("同一个行为具有多个不同表现形式或形态的能力")]),v._v("。多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：")]),v._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/%E5%A4%9A%E6%80%81.png",alt:"image-20220713203049464"}})]),v._v(" "),a("p",[v._v("⭐ "),a("strong",[v._v("存在条件")]),v._v("：继承、重写、父类引用指向子类对象")]),v._v(" "),a("h2",{attrs:{id:"面向对象和面向过程的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象和面向过程的区别"}},[v._v("#")]),v._v(" 面向对象和面向过程的区别")]),v._v(" "),a("ul",[a("li",[v._v("面向过程："),a("strong",[v._v("面向过程性能比面向对象高")]),v._v("。因为类调用需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发等一般采用面向过程开发。但是，"),a("strong",[v._v("面向过程没有面向对象易于维护、易服用、易扩展")]),v._v("。")]),v._v(" "),a("li",[v._v("面向对象："),a("strong",[v._v("易维护、易服用、易扩展")]),v._v("。因为面向对象有封装、继承、多态的特性，所以可以设计出"),a("strong",[v._v("低耦合")]),v._v("的系统，是系统更加灵活、更加易于维护。但是，"),a("strong",[v._v("面向对象性能比面向过程低")]),v._v("。")])]),v._v(" "),a("p",[v._v("java性能差的主要原因并不是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。")]),v._v(" "),a("h2",{attrs:{id:"浅拷贝vs深拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝vs深拷贝"}},[v._v("#")]),v._v(" 浅拷贝vs深拷贝")]),v._v(" "),a("ul",[a("li",[v._v("浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用的拷贝。")]),v._v(" "),a("li",[v._v("深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新对象，并复制其内容。")])]),v._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/clone.png",alt:"image-20220222210050814"}}),v._v(" "),a("h2",{attrs:{id:"java值传递"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java值传递"}},[v._v("#")]),v._v(" Java值传递")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("按值调用（call by value）：方法接收的是调用者提供的值。")])]),v._v(" "),a("li",[a("p",[v._v("按引用调用（call by reference）：方法接收的时调用者提供的变量地址。")])])]),v._v(" "),a("blockquote",[a("p",[v._v("一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。例子：")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("不能通过swap交换两个数的值")])]),v._v(" "),a("li",[a("p",[v._v("方法可以得到对象引用的拷贝，通过对象引用的拷贝可以修改这个对象的值")])]),v._v(" "),a("li",[a("p",[v._v("使用swap交换两个对象，其实交换的是两个对象引用的拷贝。")])])])]),v._v(" "),a("h2",{attrs:{id:"接口和抽象类的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类的区别"}},[v._v("#")]),v._v(" 接口和抽象类的区别")]),v._v(" "),a("ol",[a("li",[v._v("接口方法默认是public，所有方法在接口中不能实现（Java8开始接口方法可以有默认实现，default关键字定义接口可以有实现，实现该接口后无需重写default对应的方法），而抽象类可以有非抽象的方法。")]),v._v(" "),a("li",[v._v("一个类可以实现多个接口，但只能实现一个抽象类，接口也可以通过extends扩展。")]),v._v(" "),a("li",[v._v("接口方法默认访问修饰符为public；抽象方法可以有public、protected和default修饰符，因为抽象方法是为了被重写，所以不能有private。")]),v._v(" "),a("li",[v._v("从设计层面，抽象是对类的抽象，是一种模板设计；接口是对行为的抽象，是一种行为的规范。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);