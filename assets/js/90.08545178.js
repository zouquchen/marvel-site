(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{414:function(e,t,r){"use strict";r.r(t);var i=r(3),s=Object(i.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"分布式id"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式id"}},[e._v("#")]),e._v(" 分布式id")]),e._v(" "),t("h4",{attrs:{id:"_1-分布式id是什么-有哪些解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-分布式id是什么-有哪些解决方案"}},[e._v("#")]),e._v(" 1 分布式id是什么？有哪些解决方案？")]),e._v(" "),t("p",[e._v("在开发中，我们通常需要一个唯一ID来标识数据，如果是单体架构，可以通过数据库的主键，或直接在内存中维护一个自增数字来作为ID。但对于分布式系统，可能出现ID冲突。解决方案如下：")]),e._v(" "),t("ol",[t("li",[e._v("uuid，复杂度最低，但会影响存储空间和性能。")]),e._v(" "),t("li",[e._v("利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较uuid更短，但是受到单机数据库性能的限制，并发量大的时候，此方案也不是最优方案。")]),e._v(" "),t("li",[e._v("利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库相比，性能有所提高，可以适当选用。")]),e._v(" "),t("li",[e._v("雪花算法，通过某台机器在某一毫秒内对某一个数字自增，也能保证分布式架构中系统id唯一，但只能保证趋势递增。业界的tinyid、leaf等开源中间件实现了雪花算法。")])]),e._v(" "),t("h4",{attrs:{id:"_2-分布式锁的使用场景-哪些实现方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-分布式锁的使用场景-哪些实现方案"}},[e._v("#")]),e._v(" 2 分布式锁的使用场景？哪些实现方案？")]),e._v(" "),t("p",[e._v("在单体架构中，多个线程都是属于同一个进程的，所以在线程并发执行时,遇到资源竞争时，可以利用ReentrantLock、 synchronized等技术来作为锁，来控制共享资源的使用。")]),e._v(" "),t("p",[e._v("而在分布式架构中，多个线程是可能处于不同进程中的，而这些线程并发执行遇到资源竞争时，利用ReentrantLock、 synchronized等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思就是，要一个分布式锁生成器， 分布式系统中的应用程序都可以来使用这个生成器所提供的锁，从而达到多个进程中的线程使用同一把锁。")]),e._v(" "),t("p",[e._v("目前主流的分布式锁的实现方案有两种:")]),e._v(" "),t("ol",[t("li",[e._v("zookeeper：利用的是zookeeper的临时节点、顺序节点watch机制来实现的，zookeeper分布式锁的特点是高一致性, 因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱")]),e._v(" "),t("li",[e._v("redis：利用redis的setnx、 lua脚本、消费订阅等机制来实现的, redis分布式锁的特点是高可用，因为redis保证的是AP，所以由它实现的分布式锁可能不靠，不稳定（一旦redis中的数据出现了不一 致)， 可能会出现多 个户端同时加到锁的情况")])])])}),[],!1,null,null,null);t.default=s.exports}}]);